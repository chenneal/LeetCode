{
  "name": "MySolution",
  "tagline": "",
  "body": "### My main idea\r\n+ sort the list with pool_id && start_time.\r\n+ with the same pool_id, record the start_max && end_min, if cur_start > end_min, restart the process at the current position.\r\n+ do the same process with other pool_id\r\n+ loop\r\n\r\n```C++\r\n#include <iostream>\r\n#include <vector>\r\n#include <stdlib.h>\r\n\r\nusing namespace std;\r\n\r\n// define the comparation\r\nint compare(const void *a, const void *b) {\r\n\tlong long* x = (long long *)a;\r\n\tlong long* y = (long long *)b; \r\n    if (x[1] > y[1])   return 1;\r\n    else if (x[1] == y[1] && x[2] > y[2])   return 1;\r\n    else return -1; \r\n}\r\n\r\nlong long select_max_concurrent(long long **data, int N) {\r\n    // record the current pool id\r\n    long long pool_id;\r\n    // record the max number of concurrent\r\n    int max = 0;\r\n    // record the index of the connection\r\n    int count = 0;\r\n    // record the max-concurrent pool id\r\n    long long max_pool_id;\r\n    while (count < N) {\r\n        // record the max-concurrent number of current pool_id \r\n        int max_pool = 0;\r\n        // record the current concurrent number of current pool_id \r\n        int cur_max_pool = 0;\r\n        long long begin_max = 0;\r\n        long long end_min = LLONG_MAX;\r\n        pool_id = data[count][1];\r\n        while (count < N) {\r\n            // if begin_next > end_min, restart the current concurrent count\r\n            if (data[count][2] >= end_min) {\r\n                begin_max = 0;\r\n                end_min = LLONG_MAX;\r\n                count++;\r\n                cur_max_pool = 0;\r\n            }\r\n            else {\r\n                if (data[count][2] > begin_max)   begin_max = data[count][2];\r\n                if (data[count][3] < end_min)     end_min = data[count][3];\r\n                cur_max_pool++;\r\n                if (cur_max_pool > max_pool) {\r\n                    max_pool = cur_max_pool;\r\n                }\r\n                count++;\r\n            }\r\n            if (count < N) {\r\n                if (pool_id != data[count][1]) {\r\n                    break;\r\n                }\r\n            }\r\n            if (cur_max_pool > max_pool) {\r\n                max_pool = cur_max_pool;\r\n            }\r\n        }\r\n        if (max_pool > max) {\r\n            max = max_pool;\r\n            max_pool_id = pool_id;\r\n        }\r\n    }\r\n    return max_pool_id; \r\n}\r\n\r\nint main (void) {\r\n    int N;\r\n    long long **data;\r\n    long long * p;\r\n    cout << \"enter the connection number\\n\";\r\n    cin >> N;\r\n    data = (long long **) malloc (N*sizeof(long long*));\r\n    p = (long long *) malloc (4*N*sizeof(long long));\r\n\r\n    for (int i = 0; i < N; i++) {\r\n        data[i] = p;\r\n        p = p + 4;\r\n    }\r\n\r\n    for (int i = 0; i < N; i++) {\r\n        for (int j = 0; j < 4; j++) {\r\n            cin >> data[i][j];\r\n        }\r\n    }\r\n\r\n    // sort the array with the key pool_id && the start_time\r\n    qsort(data[0], N, 4*sizeof(long long), compare);\r\n\r\n    long long max_pool_id = select_max_concurrent(data, N);\r\n    // return the max_concurrent_pool_id;\r\n    cout << \"max concurrent pool id = \" << max_pool_id << endl;\r\n    return 0;\r\n}\r\n\r\n```\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}